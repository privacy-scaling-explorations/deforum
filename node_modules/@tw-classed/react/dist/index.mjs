import { jsx } from 'react/jsx-runtime';
import { parseClassNames, TW_VARS, getDataAttributes, mapPropsToVariantClass } from '@tw-classed/core';
export { getVariantConfig } from '@tw-classed/core';
import { forwardRef, useMemo } from 'react';

const COMPONENT_SYMBOL = Symbol.for("tw-classed.component");
const isClassedComponent = (value)=>{
    return (typeof value === "object" || typeof value === "function") && Reflect.has(value, COMPONENT_SYMBOL);
};

const cx = (...args)=>args.filter((v)=>!!v && typeof v === "string").join(" ");
const internalClassed = (elementType, classNames, { merger = cx } = {})=>{
    const toParse = Array.from(classNames);
    const isClassed = isClassedComponent(elementType);
    if (isClassed) {
        toParse.unshift(elementType);
    }
    const { className, variants, defaultVariants, compoundVariants, dataAttributes, defaultProps } = parseClassNames(toParse);
    const Comp = /*#__PURE__*/ forwardRef(({ as, className: cName, ...props }, forwardedRef)=>{
        const Component = isClassed ? elementType : typeof elementType === "object" ? elementType : as || elementType;
        // Map props variant to className
        const [variantClassNames, dataAttributeProps] = useMemo(()=>{
            const dataAttributeProps = getDataAttributes({
                props,
                dataAttributes,
                variants,
                defaultVariants
            });
            return [
                mapPropsToVariantClass({
                    variants,
                    defaultVariants,
                    compoundVariants
                }, props, true),
                dataAttributeProps
            ];
        }, [
            props
        ]);
        const merged = useMemo(()=>merger(className, variantClassNames, cName), [
            className,
            cName,
            variantClassNames
        ]);
        return /*#__PURE__*/ jsx(Component, {
            className: merged,
            ...props,
            ...isClassed && Object.keys(defaultVariants).length ? defaultVariants : {},
            ...dataAttributeProps,
            ...defaultProps,
            as: isClassed ? as : undefined,
            ref: forwardedRef
        });
    });
    Comp.displayName = typeof elementType !== "string" ? elementType.displayName || elementType.name || "Compoonent" : `TwComponent(${elementType})`;
    Reflect.set(Comp, TW_VARS, {
        className,
        variants,
        defaultVariants,
        compoundVariants,
        dataAttributes
    });
    Reflect.set(Comp, COMPONENT_SYMBOL, true);
    return Comp;
};
const createClassed = (config)=>{
    const classedWithConfig = (elementType, ...args)=>{
        return internalClassed(elementType, args, config);
    };
    const classedProxy = new Proxy(classedWithConfig, {
        get: (_, type)=>{
            return function(...args) {
                return classedWithConfig.apply(this, [
                    type,
                    ...args
                ]);
            };
        }
    });
    return {
        classed: classedProxy
    };
};
const makeStrict = (component)=>component;

const classedProxy = createClassed().classed;

const DERIVED_COMPONENT_SYMBOL = Symbol.for("tw.derivedComponent");
// export interface DeriveClassedFunction1 {
//   <
//     Type extends ClassedComponentType<any>,
//     Props extends {} = Omit<React.ComponentProps<Type>, "as" | "ref">,
//     HTMLType = null,
//     InferredType = HTMLType extends null ? 0 : 1
//   >(
//     callback: React.ForwardRefRenderFunction<
//       HTMLType extends null ? React.ComponentRef<Type> : HTMLType,
//       Props
//     >
//   ): HTMLType extends null
//     ? DerivedComponentType<Type, Props>
//     : DerivedComponentType<
//         React.ComponentType<any>,
//         Props & React.HTMLProps<HTMLType>,
//         Type[$$ClassedVariants]
//       >;
// }
const deriveClassed = (fn)=>{
    const derived = /*#__PURE__*/ forwardRef((props, ref)=>{
        return fn(props, ref);
    });
    /**
   * This is a derived component, so we need to set the symbol to signal internals to pass down `as` prop.
   */ Reflect.set(derived, DERIVED_COMPONENT_SYMBOL, true);
    Reflect.set(derived, COMPONENT_SYMBOL, true);
    derived.displayName = `Tw.DerivedComponent`;
    return derived;
};

export { classedProxy as classed, createClassed, cx, deriveClassed, makeStrict };
