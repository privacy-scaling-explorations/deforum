// This is your Prisma schema file
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String          @id @default(uuid()) @db.Uuid
  username      String
  avatar        String?
  email         String?
  publicKey     String[]
  website       String?
  bio           String?
  isAnon        Boolean         @default(false) @map("is_anon")
  createdAt     DateTime        @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime?       @map("updated_at") @db.Timestamptz
  posts         Post[]
  replies       PostReply[]
  userBadges    UserBadge[]
  communities   CommunityMember[]

  @@map("users")
}

model Protocol {
  id          String      @id @default(uuid()) @db.Uuid
  name        String
  slug        String      @unique
  description String?
  isActive    Boolean     @default(true) @map("is_active")
  createdAt   DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime?   @map("updated_at") @db.Timestamptz
  badges      Badge[]     // The types of badges this protocol can issue

  @@map("protocols")
}

model Badge {
  id              String       @id @default(uuid()) @db.Uuid
  name            String
  slug            String       @unique
  description     String?
  protocol        Protocol     @relation(fields: [protocolId], references: [id])
  protocolId      String       @map("protocol_id") @db.Uuid
  metadata        Json?        // Flexible metadata about what this badge represents
  privateByDefault Boolean     @default(true) @map("private_by_default")
  expiresAfter    Int?        @map("expires_after") // Number of days after which the badge expires
  createdAt       DateTime     @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime?    @map("updated_at") @db.Timestamptz
  userBadges      UserBadge[]
  requiredFor     CommunityRequiredBadge[]

  @@map("badges")
}

model UserBadge {
  id          String    @id @default(uuid()) @db.Uuid
  user        User      @relation(fields: [userId], references: [id])
  userId      String    @map("user_id") @db.Uuid
  badge       Badge     @relation(fields: [badgeId], references: [id])
  badgeId     String    @map("badge_id") @db.Uuid
  isPublic    Boolean   @map("is_public")
  metadata    Json?     // Stores the actual verified data (like specific age, email, etc.)
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz
  verifiedAt  DateTime  @map("verified_at") @db.Timestamptz
  expiresAt   DateTime? @map("expires_at") @db.Timestamptz
  revokedAt   DateTime? @map("revoked_at") @db.Timestamptz

  @@map("user_badges")
  @@index([userId, badgeId])
}

model Community {
  id                String                 @id @default(uuid()) @db.Uuid
  name              String
  description       String?
  avatar           String?
  createdAt        DateTime               @default(now()) @map("created_at") @db.Timestamptz
  updatedAt        DateTime?              @map("updated_at") @db.Timestamptz
  members          CommunityMember[]
  posts            Post[]
  requiredBadges   CommunityRequiredBadge[]
  isPrivate        Boolean                @default(false) @map("is_private")
  // Future: could add different badge requirements for different actions
  // actionPermissions Json?  // e.g., {"post": ["badge1", "badge2"], "comment": ["badge1"]}

  @@map("communities")
}

model CommunityRequiredBadge {
  id          String    @id @default(uuid()) @db.Uuid
  community   Community @relation(fields: [communityId], references: [id])
  communityId String    @map("community_id") @db.Uuid
  badge       Badge     @relation(fields: [badgeId], references: [id])
  badgeId     String    @map("badge_id") @db.Uuid
  requirements Json?    // e.g., {"type": "domain", "domains": ["company.com"], "isPublic": true} or {"type": "emails", "emails": ["user@domain.com"], "isPublic": false}
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz

  @@map("community_required_badges")
  @@index([communityId, badgeId])
}

model CommunityMember {
  id          String    @id @default(uuid()) @db.Uuid
  community   Community @relation(fields: [communityId], references: [id])
  communityId String    @map("community_id") @db.Uuid
  user        User      @relation(fields: [userId], references: [id])
  userId      String    @map("user_id") @db.Uuid
  joinedAt    DateTime  @default(now()) @map("joined_at") @db.Timestamptz
  role        String    @default("MEMBER") // Values: "ADMIN" or "MEMBER"

  @@map("community_members")
  @@index([communityId, userId])
}

model Post {
  id                String      @id @default(uuid()) @db.Uuid
  title             String
  content           String
  author            User        @relation(fields: [authorId], references: [id])
  authorId          String      @map("author_id") @db.Uuid
  community         Community   @relation(fields: [communityId], references: [id])
  communityId       String      @map("community_id") @db.Uuid
  isAnon            Boolean     @default(false) @map("is_anon")
  anonymousMetadata Json?       @map("anonymous_metadata")
  totalViews        Int         @default(0) @map("total_views")
  reactions         Json        @default("{}") // Format: { "emoji": { "count": number, "nullifiers": string[] } }
  createdAt         DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt         DateTime?   @map("updated_at") @db.Timestamptz
  replies           PostReply[]

  @@map("posts")
  @@index([communityId, createdAt])
  @@index([authorId, createdAt])
}

model PostReply {
  id                String      @id @default(uuid()) @db.Uuid
  content           String
  post              Post        @relation(fields: [postId], references: [id])
  postId            String      @map("post_id") @db.Uuid
  author            User?       @relation(fields: [authorId], references: [id])
  authorId          String?     @map("author_id") @db.Uuid
  replyParent       PostReply?  @relation("ReplyToReply", fields: [replyParentId], references: [id])
  replyParentId     String?     @map("reply_parent_id") @db.Uuid
  childReplies      PostReply[] @relation("ReplyToReply")
  isAnon            Boolean     @default(false) @map("is_anon")
  anonymousMetadata Json?       @map("anonymous_metadata")
  createdAt         DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt         DateTime?   @map("updated_at") @db.Timestamptz

  @@map("post_replies")
  @@index([postId, createdAt])
  @@index([authorId, createdAt])
} 