import * as React$1 from 'react';
import { InferVariantProps, $$ClassedVariants, $$ClassedProps, Variants } from '@tw-classed/core';
export { InferVariantProps, getVariantConfig } from '@tw-classed/core';

/**
 * React polymorphic types
 * Redistributed as its depricated in the original package
 * @author WorkOS
 * @source https://github.com/radix-ui/primitives
 */

type Merge<P1 = {}, P2 = {}> = Omit<P1, keyof P2> & P2;
type ForwardRefExoticComponent<E, OwnProps> = React$1.ForwardRefExoticComponent<Merge<E extends React$1.ElementType ? React$1.ComponentPropsWithRef<E> : never, OwnProps & {
    as?: E;
}>>;
interface ForwardRefComponent<IntrinsicElementString, OwnProps = {}
/**
 * Extends original type to ensure built in React types play nice
 * with polymorphic components still e.g. `React.ElementRef` etc.
 */
> extends ForwardRefExoticComponent<IntrinsicElementString, OwnProps> {
    /**
     * When `as` prop is passed, use this overload.
     * Merges original own props (without DOM props) and the inferred props
     * from `as` element with the own props taking precendence.
     *
     * We explicitly avoid `React.ElementType` and manually narrow the prop types
     * so that events are typed when using React.JSX.IntrinsicElements.
     */
    <As = IntrinsicElementString>(props: As extends "" ? {
        as: keyof React$1.JSX.IntrinsicElements;
    } : As extends React$1.ComponentType<infer P> ? Merge<P, OwnProps & {
        as: As;
    }> : As extends keyof React$1.JSX.IntrinsicElements ? Merge<React$1.JSX.IntrinsicElements[As], OwnProps & {
        as: As;
    }> : never): React$1.ReactElement | null;
}

/** Narrowed function. */
type Function = (...args: any[]) => unknown;

/** Returns a widened value from the given value. */
type Widen<T> = T extends number
  ? `${T}` | T
  : T extends "true"
  ? boolean | T | "false"
  : T extends "false"
  ? boolean | T | "true"
  : T extends `${number}`
  ? number | T
  : T;

type String = string & Record<never, never>;

interface InferableClassedType {
    [$$ClassedVariants]: {
        variants?: {} | unknown;
        defaultVariants?: {} | unknown;
    };
}
type AnyComponent = React.ComponentType<any>;
type AnyClassedComponent = ClassedComponentType<any, {}, {}>;
type ComponentProps<Component> = Component extends (...args: any[]) => any ? Parameters<Component>[0] : never;
/**
 * Returns the variant props of the given component.
 */
type VariantProps<T extends InferableClassedType> = InferVariantProps<T[$$ClassedVariants]["variants"]>;
/**
 * Creates a strict version of the given component.
 * This means that all variants must be passed as props unless `defaultVariants` are defined.
 * A second generic parameter can be used to specify which variants are required. This skips the automatic detection of `defaultVariants`.
 */
type StrictComponentType<T extends AnyClassedComponent, U extends keyof VariantProps<T> | unknown = unknown, VProps extends VariantProps<T> = VariantProps<T>> = ClassedComponentType<T, Required<Pick<VProps, U extends unknown ? PickRequiredVariants<T> : U>>>;
type PickRequiredVariants<T extends AnyClassedComponent & InferableClassedType> = T[$$ClassedVariants]["defaultVariants"] extends {} ? keyof Required<Omit<VariantProps<T>, keyof T[$$ClassedVariants]["defaultVariants"]>> : never;
/**
 * Defines a Classed component.
 */
interface ClassedComponentType<Type extends keyof React.JSX.IntrinsicElements | AnyComponent, Props extends {} = {}, TComposedVariants extends {} = {}> extends ForwardRefComponent<Type, Props> {
    [$$ClassedProps]: Props;
    [$$ClassedVariants]: TComposedVariants;
}
/**
 * Defines a Derived classed component.
 * Useful when you want to extend a classed component with additional props.
 */
type DerivedComponentType<Type extends keyof React.JSX.IntrinsicElements | React.ComponentType<any>, Props extends {} = {}, TComposedVariants extends {} = {}> = ClassedComponentType<Type, Omit<Props, "as">, TComposedVariants>;
/** Returns the cumulative props from the given array of compositions. */
type ClassedComponentProps<T extends any[]> = ($$ClassedProps extends keyof T[0] ? T[0][$$ClassedProps] : T[0] extends {
    variants: {
        [name: string]: unknown;
    };
} ? InferVariantProps<T[0]["variants"]> : {}) & (T extends [lead: any, ...tail: infer V] ? ClassedComponentProps<V> : {});
/** Returns the cumulative variants from the given array of compositions. */
type ClassedComponentVariants<T extends any[]> = ($$ClassedVariants extends keyof T[0] ? T[0][$$ClassedVariants] : T[0] extends {
    variants: {
        [name: string]: unknown;
    };
} ? Pick<T[0], "variants" | "defaultVariants" | "dataAttributes"> : {}) & (T extends [lead: any, ...tail: infer V] ? ClassedComponentVariants<V> : {});
/**
 * Defines the classed function. Used to create classed components.
 */
interface ClassedFunctionType {
    <Type extends keyof React.JSX.IntrinsicElements | AnyComponent, Composers extends (string | Function | {
        base?: string;
        variants?: {
            [name: string]: unknown;
        };
        defaultVariants?: {
            [name: string]: unknown;
        };
        defaultProps?: React.ComponentProps<Type>;
    })[]>(type: Type, ...composers: {
        [K in keyof Composers]: string extends Composers[K] ? Composers[K] : Composers[K] extends string | Function ? Composers[K] : {
            base?: string;
            variants?: Variants;
            defaultVariants?: "variants" extends keyof Composers[K] ? {
                [Name in keyof Composers[K]["variants"]]?: Widen<keyof Composers[K]["variants"][Name]>;
            } : {};
            compoundVariants?: (("variants" extends keyof Composers[K] ? {
                [Name in keyof Composers[K]["variants"]]?: Widen<keyof Composers[K]["variants"][Name]> | Array<Widen<keyof Composers[K]["variants"][Name]>> | String;
            } : never) & {
                className?: String;
                class?: String;
            })[];
            dataAttributes?: "variants" extends keyof Composers[K] ? Array<keyof Composers[K]["variants"]> : Array<string>;
            defaultProps?: React.ComponentProps<Type>;
        };
    }): ClassedComponentType<Type, ClassedComponentProps<Composers>, ClassedComponentVariants<Composers>>;
}
/**
 * Defines the classed proxy function. Used to create classed components.
 */
interface ClassedProxyFunctionType<Type extends keyof React.JSX.IntrinsicElements | AnyComponent> {
    <Composers extends (string | Function | {
        base?: string;
        variants?: {
            [name: string]: unknown;
        };
        defaultVariants?: {
            [name: string]: unknown;
        };
        defaultProps?: React.ComponentProps<Type>;
    })[]>(...composers: {
        [K in keyof Composers]: string extends Composers[K] ? Composers[K] : Composers[K] extends string | Function ? Composers[K] : {
            base?: string;
            variants?: Variants;
            defaultVariants?: "variants" extends keyof Composers[K] ? {
                [Name in keyof Composers[K]["variants"]]?: Widen<keyof Composers[K]["variants"][Name]>;
            } : {};
            compoundVariants?: (("variants" extends keyof Composers[K] ? {
                [Name in keyof Composers[K]["variants"]]?: Widen<keyof Composers[K]["variants"][Name]> | Array<Widen<keyof Composers[K]["variants"][Name]>> | String;
            } : never) & {
                className?: String;
                class?: String;
            })[];
            dataAttributes?: "variants" extends keyof Composers[K] ? Array<keyof Composers[K]["variants"]> : Array<string>;
            defaultProps?: React.ComponentProps<Type>;
        };
    }): ClassedComponentType<Type, ClassedComponentProps<Composers>, ClassedComponentVariants<Composers>>;
}
/**
 * Defines the classed function. Used to create classed components.
 * @example
 * const Button = classed("button", "bg-blue-500 text-white");
 * const Link = classed.a("bg-blue-500 text-white");
 * const Text = classed.span({
 *  base: "text-gray-500",
 *  variants: {
 *  size: {
 *   sm: "text-sm",
 *   md: "text-md",
 *   lg: "text-lg",
 *  },
 * })
 */
type ClassedFunctionProxy = ClassedFunctionType & {
    [K in keyof React.JSX.IntrinsicElements]: ClassedProxyFunctionType<K>;
};

declare const classedProxy: ClassedFunctionProxy;

declare const cx: (...args: string[]) => string;
interface ClassedConfig {
    merger?: (...args: string[]) => any;
}
interface CreateClassedType {
    (config?: ClassedConfig): {
        classed: ClassedFunctionProxy;
    };
}
declare const createClassed: CreateClassedType;
type StrictClassedFunction = <T extends ClassedComponentType<any, {}>, Composers extends (keyof VariantProps<T>)[] | never[]>(comp: T, ...composers: Composers) => Composers extends never[] ? StrictComponentType<T> : StrictComponentType<T, Composers[number]>;
declare const makeStrict: StrictClassedFunction;

interface DeriveClassedFunction {
    <Type extends ClassedComponentType<any>, Props extends {} = React.ComponentProps<Type>, As extends keyof React.JSX.IntrinsicElements | unknown = unknown>(callback: React.ForwardRefRenderFunction<React.ComponentRef<As extends keyof React.JSX.IntrinsicElements ? As : Type>, React.PropsWithoutRef<As extends keyof React.JSX.IntrinsicElements ? Merge<Omit<Props, "as">, React.ComponentProps<As>> : Props>>): DerivedComponentType<Type, React.PropsWithoutRef<As extends keyof React.JSX.IntrinsicElements ? Merge<Props, React.ComponentProps<As>> : Props>>;
}
declare const deriveClassed: DeriveClassedFunction;

export { type ClassedComponentType, type ClassedConfig, type ClassedFunctionProxy, type ClassedFunctionType, type ClassedProxyFunctionType, type ComponentProps, type DeriveClassedFunction, type DerivedComponentType, type StrictComponentType, type VariantProps, classedProxy as classed, createClassed, cx, deriveClassed, makeStrict };
