Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Unique symbol used to reference the cummulitive variants,defaults & classNames of a Classed Component.
 */ const TW_VARS = Symbol.for("tw-classed.vars");

const cx = (classNames)=>classNames.filter(Boolean).join(" ");
const cn = (...classes)=>cx(classes);
const mergeClass = (c1, c2)=>{
    if (typeof c2 === "boolean") return c1;
    if (!c2) return c1;
    // Check if c1 is empty
    if (!c1) return c2;
    return c1 + " " + c2;
};

/**
 * Parses & merging variants from a given string or variant config
 * @internal
 */ const parseClassNames = (classNames)=>{
    let stringClassNames = [];
    let variantObj = {};
    let defaultVariants = {};
    let compoundVariants = [];
    let dataAttributes = new Set();
    let defaultProps = {};
    for (const className of classNames){
        if (!className) continue;
        if (typeof className === "string") {
            stringClassNames.push(className);
            continue;
        }
        if (typeof className === "object" || typeof className === "function") {
            const record = Reflect.has(className, TW_VARS) ? Reflect.get(className, TW_VARS) : className;
            if (record.variants) Object.assign(variantObj, record.variants);
            if (record.defaultVariants) Object.assign(defaultVariants, record.defaultVariants);
            if (record.compoundVariants) record.compoundVariants.forEach((cv)=>compoundVariants.push(cv));
            if (record.className) stringClassNames.push(record.className);
            if (record.base) stringClassNames.push(record.base);
            if (record.dataAttributes) record.dataAttributes.forEach((name)=>{
                dataAttributes.add(name);
            });
            if (record.defaultProps) Object.assign(defaultProps, record.defaultProps);
        }
    }
    return {
        className: cx(stringClassNames),
        variants: variantObj,
        defaultVariants,
        compoundVariants,
        dataAttributes: Array.from(dataAttributes),
        defaultProps
    };
};
/**
 * Gets the variant selector from the variant props
 */ const getVariantSelector = (variantKey, props, { defaultVariants })=>{
    var _defaultVariants_variantKey;
    const variantValue = props[variantKey];
    const vStringValue = variantValue == null ? void 0 : variantValue.toString();
    return vStringValue || (defaultVariants == null ? void 0 : (_defaultVariants_variantKey = defaultVariants[variantKey]) == null ? void 0 : _defaultVariants_variantKey.toString());
};
const mapPropsToVariantClass = ({ variants, defaultVariants, compoundVariants }, props = {}, shouldDeleteProps = false)=>{
    const matchedKeys = new Set();
    const producedClassName = Object.keys(variants).reduce((acc, variantKey)=>{
        const variantSelector = getVariantSelector(variantKey, props, {
            defaultVariants
        });
        if (!variantSelector) return acc;
        shouldDeleteProps && matchedKeys.add(variantKey);
        const variantClassName = variants[variantKey][variantSelector];
        if (!variantClassName) return acc;
        // Variant is matched
        return mergeClass(acc, variantClassName);
    }, "");
    const compoundedClassNames = getCompoundVariantClasses({
        props,
        defaultVariants
    }, compoundVariants);
    shouldDeleteProps && matchedKeys.forEach((key)=>delete props[key]);
    return mergeClass(producedClassName, compoundedClassNames == null ? void 0 : compoundedClassNames.join(" "));
};
function getCompoundVariantClasses({ props, defaultVariants }, compoundVariants = []) {
    return compoundVariants.reduce((acc, { class: cvClass, className: cvClassName, ...cvo })=>{
        const notMatched = Object.entries(cvo).some(([key, value])=>{
            const propValue = props[key];
            const valueToUse = propValue !== undefined ? propValue : defaultVariants == null ? void 0 : defaultVariants[key];
            return Array.isArray(value) ? !value.includes(valueToUse) : valueToUse !== value;
        });
        if (!notMatched) {
            if (cvClass) acc.push(cvClass);
            if (cvClassName) acc.push(cvClassName);
        }
        return acc;
    }, []);
}
function getDataAttributes({ props, dataAttributes, variants, defaultVariants }) {
    if (dataAttributes.length === 0) return {};
    return dataAttributes.reduce((acc, name)=>{
        var _variants_name;
        var _props_name;
        const variantName = (_props_name = props[name]) != null ? _props_name : defaultVariants == null ? void 0 : defaultVariants[name];
        const value = (_variants_name = variants[name]) == null ? void 0 : _variants_name[variantName];
        if (value != null) {
            acc[`data-${name}`] = variantName;
        }
        return acc;
    }, {});
}

const internalClassed = (classes, { merger = cn } = {})=>{
    // Parse classNames and variants
    const { className, variants, defaultVariants, compoundVariants } = parseClassNames(classes);
    const producer = (variantProps)=>{
        // Map variant props to className
        const variantClassName = mapPropsToVariantClass({
            variants,
            defaultVariants,
            compoundVariants
        }, variantProps);
        const extra = [
            variantProps == null ? void 0 : variantProps.className,
            variantProps == null ? void 0 : variantProps.class
        ].filter(Boolean);
        return merger(className, variantClassName, ...extra);
    };
    // Add variants to the classed producer
    Reflect.set(producer, TW_VARS, {
        className,
        variants,
        defaultVariants,
        compoundVariants
    });
    return producer;
};
const createClassed = (config)=>{
    const classed = (...args)=>internalClassed(args, config);
    return {
        classed
    };
};
const classed = createClassed().classed;
/**
 * @param component - The component to get the variant configuration for.
 * @returns The variant configuration for the given component.
 * @example
 * const button = classed("button", {
 *  variants: {
 *    size: {
 *      sm: "text-sm",
 *      md: "text-md",
 *    },
 *  },
 * });
 *
 * const { variants } = getVariantConfig(button);
 *
 * expect(variants).toEqual({
 *   size: {
 *      sm: "text-sm",
 *      md: "text-md",
 *    },
 * });
 */ function getVariantConfig(component) {
    return Reflect.get(component, TW_VARS);
}

exports.TW_VARS = TW_VARS;
exports.classed = classed;
exports.createClassed = createClassed;
exports.getCompoundVariantClasses = getCompoundVariantClasses;
exports.getDataAttributes = getDataAttributes;
exports.getVariantConfig = getVariantConfig;
exports.getVariantSelector = getVariantSelector;
exports.mapPropsToVariantClass = mapPropsToVariantClass;
exports.parseClassNames = parseClassNames;
