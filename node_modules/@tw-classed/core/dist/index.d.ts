/** Narrowed function. */
type Function = (...args: any[]) => unknown;

/** Returns a widened value from the given value. */
type Widen<T> = T extends number
  ? `${T}` | T
  : T extends "true"
  ? boolean | T | "false"
  : T extends "false"
  ? boolean | T | "true"
  : T extends `${number}`
  ? number | T
  : T;

type String = string & Record<never, never>;

type Variant = Record<string, string>;
type Variants = Record<string, Variant>;
type BooleanVariant = Record<"true", string>;
type VariantConfig<V extends Variants> = {
    variants?: V;
    className?: string;
    base?: string;
    defaultVariants?: Partial<{
        [K in keyof V]: keyof V[K];
    }>;
    compoundVariants?: Record<string, any>[];
    dataAttributes?: string[];
    defaultProps?: Record<string, unknown>;
};
type ClassNamesAndVariant<V extends Variants> = string | VariantConfig<V>;
type ClassedProducer<V extends Variants = {}> = ((variantProps: InferVariantProps<V>) => any) & {
    _def: {
        className?: string;
        base?: string;
        variants?: V;
        defaultVariants?: unknown;
    };
};
type InferVariantProps<V extends Variants | unknown | undefined = undefined> = V extends Variants ? Partial<{
    [K in keyof V]: Widen<keyof V[K]> | undefined;
}> : {};
interface PropsWithClass {
    className?: string;
    class?: string;
}
interface ClassedCreator<Props extends {} = {}> {
    (variantProps?: Props & PropsWithClass): string;
}
interface ClassedType<Props extends {} = {}, TComposedVariants extends {} = {}> extends ClassedCreator<Props> {
    [$$ClassedProps]: Props;
    [$$ClassedVariants]: TComposedVariants;
}
declare const $$ClassedProps: unique symbol;
type $$ClassedProps = typeof $$ClassedProps;
declare const $$ClassedVariants: unique symbol;
type $$ClassedVariants = typeof $$ClassedVariants;
type ClassedProps<T extends any[]> = ($$ClassedProps extends keyof T[0] ? T[0][$$ClassedProps] : T[0] extends {
    variants: {
        [name: string]: unknown;
    };
} ? InferVariantProps<T[0]["variants"]> : {}) & (T extends [lead: any, ...tail: infer V] ? ClassedProps<V> : {});
type ClassedVariants<T extends any[]> = ($$ClassedVariants extends keyof T[0] ? T[0][$$ClassedVariants] : T[0] extends {
    variants: {
        [name: string]: unknown;
    };
} ? Pick<T[0], "variants" | "defaultVariants" | "dataAttributes"> : {}) & (T extends [lead: any, ...tail: infer V] ? ClassedVariants<V> : {});
type VariantProps<T extends ClassedType<any, any>> = InferVariantProps<T[$$ClassedVariants]["variants"]>;
interface ClassedCoreFunctionType {
    <Composers extends (string | Function | {
        base?: string;
        variants?: {
            [name: string]: unknown;
        };
    })[]>(...composers: {
        [K in keyof Composers]: string extends Composers[K] ? Composers[K] : Composers[K] extends string | Function ? Composers[K] : {
            base?: string;
            variants?: Variants;
            defaultVariants?: "variants" extends keyof Composers[K] ? {
                [Name in keyof Composers[K]["variants"]]?: Widen<keyof Composers[K]["variants"][Name]>;
            } : never;
            compoundVariants?: (("variants" extends keyof Composers[K] ? {
                [Name in keyof Composers[K]["variants"]]?: Widen<keyof Composers[K]["variants"][Name]> | Array<Widen<keyof Composers[K]["variants"][Name]>> | String;
            } : never) & {
                className?: String;
                class?: String;
            })[];
            dataAttributes?: "variants" extends keyof Composers[K] ? Array<keyof Composers[K]["variants"]> : Array<string>;
        };
    }): ClassedType<ClassedProps<Composers>, ClassedVariants<Composers>>;
}

interface ClassedCoreConfig {
    merger?: (...args: string[]) => any;
}
interface CreateClassedCoreType {
    (config?: ClassedCoreConfig): {
        classed: ClassedCoreFunctionType;
    };
}
declare const createClassed: CreateClassedCoreType;
declare const classed: ClassedCoreFunctionType;
declare function getVariantConfig<T extends {
    [$$ClassedVariants]: {};
}>(component: T): T[typeof $$ClassedVariants];

declare const parseClassNames: <TVariants extends Variants>(classNames: any[]) => {
    className: string;
    variants: TVariants;
    defaultVariants: Partial<Partial<{ [K in keyof TVariants]: keyof TVariants[K]; }>>;
    compoundVariants: Record<string, any>[];
    dataAttributes: string[];
    defaultProps: Record<string, unknown>;
};
declare const getVariantSelector: <TVariants extends Variants>(variantKey: string, props: Partial<InferVariantProps<TVariants>>, { defaultVariants }: Pick<VariantConfig<TVariants>, "defaultVariants">) => string | undefined;
declare const mapPropsToVariantClass: <TVariants extends Variants, TRecord extends VariantConfig<TVariants> = VariantConfig<TVariants>>({ variants, defaultVariants, compoundVariants, }: {
    variants: TVariants;
    defaultVariants: TRecord["defaultVariants"];
    compoundVariants?: Record<string, any>[] | undefined;
}, props?: Partial<InferVariantProps<TVariants>>, shouldDeleteProps?: boolean) => string;
declare function getCompoundVariantClasses({ props, defaultVariants, }: {
    defaultVariants: VariantConfig<any>["defaultVariants"];
    props: Record<string, any>;
}, compoundVariants?: VariantConfig<any>["compoundVariants"]): string[];
declare function getDataAttributes({ props, dataAttributes, variants, defaultVariants, }: {
    props: Record<string, any>;
    dataAttributes: string[];
    variants: VariantConfig<any>["variants"];
    defaultVariants: VariantConfig<any>["defaultVariants"];
}): Record<string, string>;

declare const TW_VARS: unique symbol;

export { $$ClassedProps, $$ClassedVariants, type BooleanVariant, type ClassNamesAndVariant, type ClassedCoreConfig, type ClassedCoreFunctionType, type ClassedProducer, type ClassedProps, type ClassedType, type ClassedVariants, type CreateClassedCoreType, type InferVariantProps, TW_VARS, type Variant, type VariantConfig, type VariantProps, type Variants, classed, createClassed, getCompoundVariantClasses, getDataAttributes, getVariantConfig, getVariantSelector, mapPropsToVariantClass, parseClassNames };
